indexvar index, i, j, n, m  ::= {{ isa nat }} {{ coq nat }} {{ hol num }} {{ lex numeral }}
  {{ com indices }}

grammar

T, K :: 'ti_' ::= {{ com Type indices }}
  | Base      ::  :: base  {{ com base type }} {{ tex \mathbb{B} }}
  | X         ::  :: var   {{ com type variable }}
  | -> T      ::  :: arrow {{ com function type }} {{ tex \overrightarrow{[[T]]} }}
  | \-/ T     ::  :: all   {{ com universal type }} {{ tex [[T]]^\forall }}
  | { l : T } ::  :: rcd   {{ com record type }}
  | T1 & T2   ::  :: and   {{ com intersection type }}
  | | A |     :: M:: translation {{ tex |[[A]]| }}
  | ( A )     :: S:: paren
  | Int       :: M:: int     {{ com int }} {{ tex \mathsf{Int}  }}
  | Bool      :: M:: bool    {{ com bool}} {{ tex \mathsf{Bool} }}

xx :: 'var_' ::=
  | x                                     :: :: evar     {{ com term variable }}
  | X                                     :: :: tvar     {{ com type variable }}

ll :: 'label_' ::=
  | l                                     :: :: label
  | itoa ( A )                            :: :: itoa     {{ tex \mathbf{itoa}([[A]]) }}

target_exp, t, te, tp, tv, tu :: 'tt_' ::=                  {{ com target term  }}
  | xx                                     :: :: var     {{ com variable }}
  % | null                                  :: :: empty   {{ com empty record }} {{ tex \varnothing }}
  | ll                                     :: :: label   {{ com first-class label }}
  | b                                     :: :: base    {{ com base value }} {{ tex \mathsf{[[b]]}  }}
  | \ _ . t                               :: :: thunk   
                                                        {{ com variable is not used }}
  | \ xx . t                               :: :: abs     (+ bind xx in t +)
                                                        {{ com abstractions }}
  % | /\ X . t                              :: :: tabs    (+ bind X in t +)
  %                                                       {{ com abstractions that take a type index }}
  | fix x . t                             :: :: fixpoint
                                                        (+ bind x in t +)
                                                        {{ com fixpoint }}
  | t1 t2                                 :: :: app     {{ com applications }}
  | t1 ; ... ; tn                         :: :: concat  {{ com concatenation }}
  % | { T1 => t1 ,  .. , Tn => tn }         :: :: merge
  | { t1 => t1' ,  .. , tn => tn' }        :: :: record
 % | { </ li = ti // i /> }                :: :: Rec_comp_none   {{ com record --- comp }}
 % | { </ li = ti // , // i /> }           :: :: Rec_comp_some   {{ com record --- comp with terminal }}
 % | { </ li = ti // i IN n /> }           :: :: Rec_comp_u_none {{ com record --- compu }} 
 % | { </ li = ti // , // i IN n /> }      :: :: Rec_comp_u_some {{ com record --- compu with terminal }} 
 % | { </ li = ti // i IN 1 .. n /> }      :: :: Rec_comp_lu_none{{ com record --- complu }}  
  % | { </ li = ti // , // i IN 1 .. n /> } :: :: Rec_comp_lu_some {{ com record --- complu with terminal }}  
  | t1 . t2                                 :: :: proj     {{ com projection }}
  | ( t )                                 :: S:: paren
  | t1 [ xx ~> t2 ]                        :: M:: subst   {{ com subst }}
  % | t [ X ~> T ]                          :: M:: tsubst  {{ com subst type index }}  
  | E [ t ]                               :: S:: FillEctx
  | T                                     :: M:: index     {{ com type index as a label }}

E :: 'ectx_' ::= {{ com evaluation context }}
  | [-]      ::  :: Hole
  | E . t    ::  :: ProjL   {{ com projection }}
  | tv . E   ::  :: ProjR   {{ com projection }}
  | E t      ::  :: AppL
  | tv E     ::  :: AppR
  | E ; t    ::  :: ConcatL {{ com concatenation }}
  | tv ; E   ::  :: ConcatR {{ com concatenation }}
  % | { E => t , t1 => t1', .. , tn => tn' }  :: :: record1 {{ com eval the first label }}
  % | { l => E , t1 => t1', .. , tn => tn' }  :: :: record2 {{ com eval the first field }} 
  | { l1 => tv1 ,  .. , lm => tvm , E => t , t1 => t1' , .. , tn => tn' }    :: :: record1 {{ com eval a label }}
  | { l1 => tv1 ,  .. , lm => tvm , l => E , t1 => t1' ,  .. , tn => tn' }   :: :: record2 {{ com eval a field }}

ST :: 'set_' ::= {{ com set of type indices }}
  | null              :: M:: empty {{ tex \varnothing }}
  | ST1 /\ ST2        :: M:: intersect {{ tex [[ST1]]\cap[[ST2]] }}
  | { l1 , .. , ln }  ::  :: nonemptyset
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
defns
TargetStep   :: '' ::=

  defn
  t >-> t'
  :: :: target_step :: 'TS_'
  {{ com Record Calculus Structrual Reduction }}
  by

  t >-> t'
  -------------------- :: ctx
  E [ t ] >-> E [ t' ]

  { l1 , .. , lm } /\ { l } = null
  { l1' , .. , ln' }  /\ { l } = null
  --------------------------------------------------------------------------------- :: proj
  { l1 => tv1 ,  .. , lm => tvm, l => tv , l1'=>tv1' , .. , ln' => tvn' } . l >-> tv

  { l1 , .. , lm } /\ { l1' , .. , ln' } = null
  --------------------------------------------------------------------------------- :: concat
  { l1 => tv1 ,  .. , lm => tvm } ; { l1' => t1' ,  .. , ln' => tn' } >-> { l1 => tv1 ,  .. , lm => tvm , l1' => t1' ,  .. , ln' => tn'}

  % --------------------------------------------------------------------------------- :: concat2
  % {}; { T1 => t1 ,  .. , Tn => tn } >-> { T1 => t1 ,  .. , Tn => tn }
  
  % tvi = \ x . t
  % ---------------------------------------------------------------------------------------- :: beta
  % { T1 => tv1 ,  ... , Tn => tvn }.Ti  { K1 => tu1 ,  ... , Km => tum }.Kj  >-> t [ x ~> tuj ]

  ----------------------------- :: beta
  \ x . t  tv  >-> t [x~>tv]
  
  % ----------------------------- :: beta2
  % /\ X . t  T  >-> t [X~>T]
  
  % --------------------- :: beta3
  % \ _ . t  tv  >-> t

  ----------------------------- :: fix
  fix x . t >-> t [x~>fix x.t]


defns
DistributiveApplication :: '' ::=

  defn
  t1 : A ; t2 ~~> t3 :: :: distapp :: A_
  {{ com Distributive application }}
  by

  toplike A
  ---------------------------- :: Top
  t1 : A ; t2 ~~> { }

  ---------------------------------- :: Arrow
  t1 : A -> B ; t2 ~~> t1.->|B| t2

  ----------------------------------------- :: All
  t1 : Forall X*A. B ; t2 ~~> t1.\-/|B| t2

  ----------------------------------- :: Rcd
  t : {l : A} ; l ~~> t.{l : |A|} {}

  t : A ; t2 ~~> t1
  t : B ; t2 ~~> t2
  ------------------------------ :: And
  t : A & B ; t2 ~~> t1; t2


  
defns
Elaboration :: '' ::=

  defn
  G |- e mode A ~~> t
  :: :: elaboration :: 'Ela_'
  {{ com Elaboration }}
  by


  -------------------------------- :: Top
  G |- top => Top ~~> {}


  toplike B
  --------------------------------------- :: TopAbs
  G |- \x:A. e:B => A->B ~~> {}


  toplike B
  -------------------------------------------------------- :: TopTAbs
  G |- /\ X * A. e : B => Forall X * A. B ~~> {}


  G |- e => A ~~> t
  toplike A
  ---------------------------------------- :: TopRcd
  G |- {l = e} => {l : A} ~~> {}


  ------------------------------ :: Base
  G |- b => Base ~~> {|Base| => b }


  x : A in G
  --------------------------- :: Var
  G |- x => A ~~> x { }


% x : A in G
% ----------------------- :: VarGen
% G |- x => A ~~> S3 | z+


  G, x:A |- e <= A ~~> t
  ----------------------------------- :: Fix
  G |- fix x:A. e => A ~~> fix x . t 


  G, x:A |- e <= B ~~> t
  ----------------------------------------- :: Abs
  G |- \x:A. e:B => A->B ~~> {->|B| =>\x.t}


  G |- e1 => A ~~> t1
  A |> B -> C
  G |- e2 <= B ~~> t2
  t1 : A ; t2 ~~> t3
  --------------------------------------------------------- :: App
  G |- e1 e2 => C ~~> t3


  G , X * A |- e <= B ~~> t
  ----------------------------------------------------------------- :: TAbs
  G |- /\ X * A. e : B => Forall X * A. B ~~> {\-/|B| => \ X . t}


  G |- e => B ~~> t1
  B |> Forall X*C1. C2
  G |- A * C1
  t1 : B ; itoa(A) ~~> t3
  --------------------------------------------------------------------- :: TApp
  G |- e A => C2 [X~>A] ~~> t3

  G |- e => A ~~> t
  ------------------------------------------------- :: Rcd
  G |- {l = e} => {l : A} ~~> { {l : |A|} => \_.t }


  G |- e => A ~~> t1
  A |> {l : B}
  t1 : A ; {} ~~> t2
  -------------------------------------------------------------------- :: Proj
  G |- e.l => B ~~> t1


  G |- e1 => A ~~> t1
  G |- e2 => B ~~> t2
  G |- A * B
  ------------------------------------- :: Merge
  G |- e1 ,, e2 => A & B ~~> t1;t2


  G |- e <= A ~~> t
  ------------------------ :: Anno
  G |- e:A => A ~~> t


% G |- e <= A ~~> t | z+
% ------------------------ :: AnnoGen
% G |- e:A => A ~~> t | z+


  G |- e => A ~~> t1
  t1 : A <: B ~~> t2
  -------------------------- :: Sub
  G |- e <= B ~~> t2


% G |- e => A ~~> t | z-
% ---------------------- :: SubEq
% G |- e <= A ~~> t | z-


% G |- e => A ~~> t | z+
% ---------------------- :: SubEqGen
% G |- e <= A ~~> t | z+



defns
CoSubtyping :: '' ::=

  defn
  t1 : A <: B ~~> t2 :: :: cosub :: S_
  {{ com Coercive subtyping }}
  by

  ordinary B
  toplike B
  -------------------------- :: Top
  t : A <: B ~~> {}

  ------------------------------------ :: Base
  t : Base <: Base ~~> {Base=> t.Base}

  % fresh x 
  ordinary B2
  x {} : B1 <: A1 ~~> t1
  (t.->|A2|) (\_.t1) : A2 <: B2 ~~> t2
  -------------------------------------------------------------------- :: Arrow
  t : A1 -> A2 <: B1 -> B2 ~~> { ->|B2| => \x. t2 }

  % fresh X
  ordinary B2
  B1 <: A1
  (t.\-/|A2|) X : A2 <: B2 ~~> t2
  -------------------------------------------------------------------- :: All
  t : Forall X*A1. A2 <: Forall X*B1. B2 ~~> { \-/|B2| => \X. t2 }

  ordinary B
  t.{l : |A|} {} : A <: B ~~> t2
  ---------------------------------------------- :: Rcd
  t : {l:A} <: {l:B} ~~> {{l : |B|} => t2 }

  ordinary C
  t : A <: C ~~> t'
  ------------------------ :: AndL
  t : A & B <: C ~~> t'

  ordinary C
  t : B <: C ~~> t'
  ------------------------ :: AndR
  t : A & B <: C ~~> t'

  split B B1 B2
  t : A <: B1 ~~> t1
  t : A <: B2 ~~> t2
  t1 : B1 |> B <| t2 : B2 ~~> t3
  -------------------------------- :: Split
  t : A <: B ~~> t3


defns
CoMerge :: '' ::=

  defn
  t1 : A |> C <| t2 : B ~~> t :: :: comerge :: M_
  {{ com Coercive merging }}
  by
  ---------------------------------------- :: And
  t1 : A |> A&B <| t2 : B ~~> x ; y 

  (t1.->|B1|) x : B1 |> B <| (t2.->|B2|) x : B2 ~~> t
  ------------------------------------------------------------- :: Arrow
  t1 : A->B1 |> A->B <| t2 : A->B2 ~~> { ->|B| => \ x . t }

  (t1.\-/|B1|) x : B1 |> B <| (t2.\-/|B2|) x : B2 ~~> t
  -------------------------------------------------------------------------------------- :: All
  t1 : Forall X*A. B1 |> Forall X*A. B <| t2 : Forall X*A. B2 ~~> { \-/|B| => \ x . t }

  (t1.{l:|A1|}) {} : A1 |> A <| (t2.{l:|A2|}) {} : A2 ~~> t
  --------------------------------------------------------------- :: Rcd
  t1 : {l:A1} |> {l:A} <| t2 : {l:A2} ~~> {{l:|A|} => \ x . t }
