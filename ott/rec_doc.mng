\documentclass{article}

\usepackage[normalem]{ulem}
\usepackage{amsmath,amssymb}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}
\usepackage{ottalt}
\usepackage{xcolor}
\usepackage{xspace}

\inputott[ott]{record}

\newcommand\calculus{$\mathsf{F}_i^+$\xspace}
\newcommand\reccal{$\lambda^{\text{rec}}$\xspace}

\title{Elaborating \calculus to record calculus \reccal}
\author{Snow}

\begin{document}

\maketitle

\section{Notes}
\paragraph{Problems}
0) Duplicated labels in records are unsafe in the target calculus.
How to compile $1:Int\&Int$? \\
1) Subtyping does not produce unique coercion so coherence is a problem.


\paragraph{Changes in \reccal}
0) Use first-class labels\\
1) Unify the abstractions in expressions
2) Refine the syntax and related rules of records and projections as the label
could be an expression


\paragraph{Changes in elaboration}
0) Add distributive application and revise the related typing rules\\
1) Pass terms to coercive subtyping instead of generating coercions \\
2) Update coercion rules for arrows

\newpage

\section{Syntax of \reccal}


\begin{align*}
  %% &\text{Type indices (labels)}&[[T]], [[K]] ::=&~ [[Base]] ~|~ [[->T]] ~|~ [[\-/T]] ~|~ [[{l : T}]] ~|~ [[T1 & T2]] \\
  &\text{Target expressions} &[[t]] ::=& [[l]] ~|~ [[b]] ~|~ [[x]] ~|~ [[fix x. t]] ~|~ [[\x. t]] ~|~ [[t1 t2]] ~|~ [[{ t1 => t1' ,  .. , tn => tn' }]] ~|~ [[t1.t2]] ~|~ [[t1 ; t2]] \\
  &\text{Target values}      &[[tv]], [[tu]] ::=& [[b]] ~|~ [[\x. t]] ~|~ [[{ l1 => tv1 ,  .. , ln => tvn }]] \\
\end{align*}

\paragraph{Notes}
0) Multi-field records are nullable. $[[\_.t]]$ denotes $[[\x.t]]$ where $x$ does not appear in $t$.\\
\sout{1) We need functions that take a type index for big lambda expressions and type applications.} \\
2) The whole program has a record form.
3) $l$ stands for a string.
%% 2) As any expression can be concatenated, all values should have a record form.
%% For example, we cannot evaluates $[[{ ->Base => \x.b }.->Base]]$ in $[[ [-];{Base=>b} ]] $.
%% It is hard to express lazy evaluation then.
%% Our evaluation strategy is eager but when constructing records, each field is
%% in a thunk so they will not be evaluated until projection.

%% \paragraph{Questions}
%% (/\ X * Top . \ x : X . x : X)

\ottgrammartabular{
  \ottE
}

\ottdefnsTargetStep

\paragraph{Problems}
\sout{0) To achieve a safe language, we need to check the projected label is unique in TS-proj.} \\
1) The side-condition in rule TS-concat does not guarantee the original types are
disjoint. E.g. $[[ {Int=>b1,Bool=>b2} ; {Int&Bool=>b3 } ]]$\\
2) Regarding efficiency, the time cost of concatenation is high.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Syntax of \calculus}
\begin{align*}
  &\text{Types}       &A,B,C ::=&~ [[Top]] ~|~ [[Bot]] ~|~ [[Base]] ~|~ [[X]] ~|~ [[A -> B]] ~|~ [[Forall X*A. B]] ~|~ [[{l : A}]] ~|~ [[A & B]] \\
  &\text{Type indices}&[[T]] ::=&~ [[Base]] ~|~ [[->T]] ~|~ [[\-/T]] ~|~ [[{l : T}]] ~|~ [[T1 & T2]] \\
  &\text{Expressions} &    e ::=&~ [[{}]] ~|~ [[b]] ~|~ [[x]] ~|~ [[fix x:A. e]] ~|~ [[\x:A. e:B]] ~|~ [[e1 e2]] ~|~ [[/\X*A. e:B]] ~|~ [[e A]] ~|~ [[{l = e}]] ~|~ [[e.l]] \\
  &                   &        |&~ [[e1 ,, e2]] ~|~ [[e : A]] \\
  &\text{Values}      &    v ::=&~ [[{}]] ~|~ [[b]] ~|~ [[\x:A. e:B]] ~|~ [[/\X*A. e:B]] ~|~ [[{l = v}]] ~|~ [[v1 ,, v2]] \\
\end{align*}

\subsection{Mapping between source types and target values}
\begin{align*}
  & [[A&B]] && [[ { |A| => t1 , |B| => t2 } ]] \\
  & [[Top]] && [[ { } ]] \\
  & [[Bot]] && \\
  & [[Base]] && [[ { Base => b } ]] \\
  & [[X]]   && [[ { X => t } ]] ~\text{(not a value)} \\
  & [[A->B]] && [[ { ->|B| => \x.t } ]] \\
  & [[Forall X*A.B]] && [[ { \-/|B| => \X.t } ]] \\
  & [[{l:A}]] && [[ { {l:|A|} => \_.t } ]]
\end{align*}

\subsection{Elaboration rules}
1) All top-like values are translated into empty lists.

\begin{mathpar}
  \ottdruleElaXXTop{} \and
  \ottdruleElaXXTopAbs{} \and
  \ottdruleElaXXTopTAbs{} \and
  \ottdruleElaXXTopRcd{}
\end{mathpar}

2) All basic values (that are not merges) are translated into single-field records.

\begin{mathpar}
  \ottdruleElaXXBase{} \and
  \ottdruleElaXXAbs{} \and
  \ottdruleElaXXTAbs{} \and
  \ottdruleElaXXRcd{}
\end{mathpar}

3) Variables are directly used (unwrap the thunk) and merged terms are simply concatenated,
with the expectation that $[[ []|-e=>A ~~> t ]]$ implies $[[ t >->* {|A|=>t'} ]]$
(or a multi-field record) (i.e. the variable will be substituted
by a term of this exact type).

\begin{mathpar}
  \ottdruleElaXXVar{} \and
  \ottdruleElaXXMerge{}
\end{mathpar}

4) Projection, application, and type application make use of the property
that every translated subterms are records. Application is lazy.

\begin{mathpar}
  \ottdruleElaXXProj{} \and
  \ottdruleElaXXApp{} \and
  \ottdruleElaXXTApp{}
\end{mathpar}

5) Annotated expressions, like fixpoints, rely on the subsumption rule to
insert coercions. The coerced expression always evaluates to a record.

\begin{mathpar}
  \ottdruleElaXXAnno{} \and
  \ottdruleElaXXFix{} \and
  \ottdruleElaXXSub{}
\end{mathpar}

\subsection{Coercions}
\begin{align*}
  & [[ x : Int & Bool <: Int ~~> { Int => x . Int } ]] \\
  & [[ x : Int & Bool <: Bool&Int ~~> { Bool => x . Bool } ; {Int => x . Int } ]]  \\
  %% && [[ {Int&Bool=>x{}} ]] \\
  & [[ x : Base->Int&Bool <: Base->Int&Bool ~~> { ->(Int&Bool) => \ y . (x.->Int)y; (x.->Bool)y } ]]
\end{align*}

\paragraph{Problems}
1) Derivation of subtyping is not unique. No type well-formedness, no coherence. \\
2) The algorithm is against the effort we put in typing application. As types
are split whenever possible, functions are duplicated (and merged afterwards). \\
\sout{3) It is strange that the domain of arrow types has no effect to coercion generation.}

\ottdefnsCoSubtyping

\ottdefnsCoMerge

\subsection{Auxiliary definitions}

\boxed{[[|A|]] = [[T]]} \hfill \textit{(Type translation)}
\begin{mathpar}
\inferrule{}{ [[|Base|]] = [[Base]] }
\and
\inferrule{}{ [[|X|]] = \mathbf{atoi}(X) }
\and
\inferrule{}{ [[|Forall X*A. B|]] = [[\-/|B|]] }
\and
\inferrule{}{ [[|A->B|]] = [[->|B|]] }
\and
\inferrule{}{ [[|{l:A}|]] = [[{l:|A|}]] }
\and
\inferrule
{ A_{k_1} < A_{k_2} < \cdots < A_{k_m} \\ \neg \rceil A_k \lceil }
{ |A_1\&A_2\&\cdots\&A_n| = |A_{k_1}|\&|A_{k_2}|\&\cdots\&|A_{k_m}| }
\end{mathpar}

\bigskip\bigskip

\ottdefntoplike

\ottdefnordinary

\end{document}
