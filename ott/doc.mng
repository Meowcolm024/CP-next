\documentclass{article}

\usepackage{amsmath,amssymb}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}
\usepackage{ottalt}
\usepackage{xcolor}
\usepackage{xspace}

\inputott{ott}

\newcommand\calculus{$\mathsf{F}_i^+$\xspace}

\title{Compiling from \calculus to JavaScript}
\author{Yaozhu Sun}

\begin{document}

\maketitle

\section*{Syntax of \calculus}
\begin{align*}
  &\text{Types}       &A,B,C ::=&~ [[Top]] ~|~ [[Bot]] ~|~ [[Base]] ~|~ [[X]] ~|~ [[A -> B]] ~|~ [[Forall X*A. B]] ~|~ [[{l : A}]] ~|~ [[A & B]] \\
  &\text{Type indices}&[[T]] ::=&~ [[Base]] ~|~ [[->T]] ~|~ [[\-/T]] ~|~ [[{l : T}]] ~|~ [[T1 & T2]] \\
  &\text{Expressions} &    e ::=&~ [[{}]] ~|~ [[b]] ~|~ [[x]] ~|~ [[fix x:A. e]] ~|~ [[\x:A. e:B]] ~|~ [[e1 e2]] ~|~ [[/\X*A. e:B]] ~|~ [[e A]] ~|~ [[{l = e}]] ~|~ [[e.l]] \\
  &                   &        |&~ [[e1 ,, e2]] ~|~ [[e : A]] \\
  &\text{Values}      &    v ::=&~ [[{}]] ~|~ [[b]] ~|~ [[\x:A. e:B]] ~|~ [[/\X*A. e:B]] ~|~ [[{l = v}]] ~|~ [[v1 ,, v2]] \\
\end{align*}

\noindent
\boxed{[[|A|]] = [[T]]} \hfill \textit{(Type translation)}
\begin{mathpar}
\inferrule{}{ [[|Base|]] = [[Base]] }
\and
\inferrule{}{ [[|X|]] = \mathbf{atoi}(X) }
\and
\inferrule{}{ [[|A->B|]] = [[->|B|]] }
\and
\inferrule{}{ [[|Forall X*A. B|]] = [[\-/|B|]] }
\and
\inferrule{}{ [[|{l:A}|]] = [[{l:|A|}]] }
\and
\inferrule
{ A_{k_1} < A_{k_2} < \cdots < A_{k_m} \\ \neg \rceil A_k \lceil }
{ |A_1\&A_2\&\cdots\&A_n| = |A_{k_1}|\&|A_{k_2}|\&\cdots\&|A_{k_m}| }
\end{mathpar}

\ottdefntoplike

\ottdefnordinary

\newpage
\ottdefncompile
\bigskip\bigskip\bigskip

\begin{multicols}{3}
\begin{verbatim}
/* J-Gen */
var z = {};  J;

/* J-Base */
z[T] = b;

/* J-Var */
Object.assign(z, x.get);

/* J-VarGen */
var z = x.get;

/* J-Fix */
var x = { get: z };
J;

/* J-Abs */
z[T] = (x, y) => { J };

/* J-App */
J1;
var y0 = {
  get get() {
    J2;
    Object.defineProperty(
      this, "get",
      {value: y}
    );  return y;
  }
};  J3;

/* J-TAbs */
z[T] = (X, y) => { J };

/* J-Rcd */
z[T] = {
  get get() {
    J;
    Object.defineProperty(
      this, "get",
      {value: y}
    );  return y;
  }
};
\end{verbatim}
\end{multicols}

\vfill
\ottdefndistapp

\begin{multicols}{3}
\begin{verbatim}
/* A-Arrow */
x[T](y, z);

/* A-All */
x[T](Ts, z);

/* A-Rcd */
Object.assign(z, x[T].get);
\end{verbatim}
\end{multicols}

\newpage
\ottdefncosub

\begin{multicols}{3}
\begin{verbatim}
/* S-Bot */
y[T] = null;

/* S-Eq */
Object.assign(y, x);

/* S-Base */
y[T] = x[T];

/* S-Var */
for (var T of X) {
  y[T] = x[T];
}

/* S-Arrow */
y[T2] = (p, y2) => {
  var x2 = {};
  x[T1]({
    get get() {
      var x1 = p.get;
      var y1 = {};  J1;
      Object.defineProperty(
        this, "get",
        {value: y1}
      );  return y1;
    }
  }, x2);
  J2;
};

/* S-All */
y[T2] = (X, y0) => {
  var x0 = {};
  x[T1](X, x0);
  J;
};

/* S-Rcd */
y[T2] = {
  get get() {
    var x0 = x[T1].get;
    var y0 = {};  J;
    Object.defineProperty(
      this, "get",
      {value: y0}
    );  return y0;
  }
}

/* S-Split */
var y1 = {}; // if y1 != z
var y2 = {}; // if y2 != z
J1;  J2;  J3;
\end{verbatim}
\end{multicols}

\newpage
\ottdefncomerge

\begin{multicols}{3}
\begin{verbatim}
/* M-Arrow */
z[T] = (p, y) => {
  var y1 = {}; // if y1 != y
  var y2 = {}; // if y2 != y
  x1[T1](p, y1);
  x2[T2](p, y2);
  J;
};







/* M-All */
z[T] = (X, y) => {
  var y1 = {}; // if y1 != y
  var y2 = {}; // if y2 != y
  x1[T1](X, y1);
  x2[T2](X, y2);
  J;
};







/* M-Rcd */
z[T] = {
  get get() {
    var y = {};
    var y1 = {}; // if y1 != y
    var y2 = {}; // if y2 != y
    Object.assign(y1, x1[T1].get);
    Object.assign(y2, x2[T2].get);
    J;
    Object.defineProperty(
      this, "get",
      {value: y}
    );  return y;
  }
};
\end{verbatim}
\end{multicols}

\end{document}
