grammar

T :: 'ti_' ::= {{ com Type indices }}
  | Base      ::  :: base  {{ com base type }} {{ tex \mathbb{B} }}
  | -> T      ::  :: arrow {{ com function type }} {{ tex \overrightarrow{[[T]]} }}
  | \-/ T     ::  :: all   {{ com universal type }} {{ tex [[T]]^\forall }}
  | { l : T } ::  :: rcd   {{ com record type }}
  | T1 & T2   ::  :: and   {{ com intersection type }}
  | | A |     :: M:: translation {{ tex |[[A]]| }}
  | ( A )     :: S:: paren

J, code {{ tex \mathtt{code} }} :: 'js_' ::= {{ com JavaScript statements }}
  | nothing ::  :: empty {{ tex \varnothing }}
  | J1 ; J2 ::  :: concat

varname {{ tex z^\pm }} :: 'vn_' ::= {{ com variable names }}
  | z - ::  :: i {{ tex [[z]]^- }}
  | z + ::  :: o {{ tex [[z]]^+ }}



defns
Compilation :: '' ::=

defn
G |- e mode A ~~> J | varname :: :: compile :: J_
{{ com Type-directed compilation }}
{{ tex [[G]][[|-]][[e]][[mode]][[A]]\;\colorbox{lightgray}{$[[~~>]][[J]]\;|\;[[varname]]$} }}

% G |- e mode A ~~> z in J :: :: compile :: J_
% {{ com Type-directed compilation }}
% {{ tex [[G]][[|-]][[e]][[mode]][[A]]\;\colorbox{lightgray}{$[[~~>]][[z]]\;\textbf{in}\;[[J]]$} }}

by

G |- e mode A ~~> J | z-
--------------------------- :: Gen
G |- e mode A ~~> code | z+


-------------------------------- :: Top
G |- {} => Top ~~> nothing | z-


toplike B
--------------------------------------- :: TopAbs
G |- \x:A. e:B => A->B ~~> nothing | z-


toplike B
-------------------------------------------------------- :: TopTAbs
G |- /\ X * A. e : B => Forall X * A. B ~~> nothing | z-


G |- e => A
toplike A
---------------------------------------- :: TopRcd
G |- {l = e} => {l : A} ~~> nothing | z-


T = |Base|
---------------------------- :: Base
G |- b => Base ~~> code | z-


x : A in G
------------------------- :: Var
G |- x => A ~~> code | z-


x : A in G
------------------------- :: VarGen
G |- x => A ~~> code | z+


G, x:A |- e <= A ~~> J | z-
---------------------------------- :: Fix
G |- fix x:A. e => A ~~> code | z-


T = ->|B|
G, x:A |- e <= B ~~> J | y-
------------------------------------ :: Abs
G |- \x:A. e:B => A->B ~~> code | z-


G |- e1 => A ~~> J1 | x+
A |> B -> C
G |- e2 <= B ~~> J2 | y+
x : A ; y0 ~~> J3 | z
----------------------------- :: App
G |- e1 e2 => C ~~> code | z-


T = \-/|B|
G , X * A |- e <= B ~~> J | y-
----------------------------------------------------- :: TAbs
G |- /\ X * A. e : B => Forall X * A. B ~~> code | z-


G |- e => B ~~> J1 | y+
B |> Forall X*C1. C2
G |- A * C1
Ts = itoa |A|
y : B ; Ts ~~> J2 | z
------------------------------------ :: TApp
G |- e A => C2 [X~>A] ~~> J1;J2 | z-


T = {l : |A|}
G |- e => A ~~> J | y+
------------------------------------- :: Rcd
G |- {l = e} => {l : A} ~~> code | z-


G |- e => A ~~> J1 | y+
A |> {l : B}
y : A ; l ~~> J2 | z
---------------------------- :: Proj
G |- e.l => B ~~> J1;J2 | z-


G |- e1 => A ~~> J1 | z-
G |- e2 => B ~~> J2 | z-
G |- A * B
------------------------------------- :: Merge
G |- e1 ,, e2 => A & B ~~> J1;J2 | z-


G |- e <= A ~~> J | z-
------------------------ :: Anno
G |- e:A => A ~~> J | z-


G |- e <= A ~~> J | z+
------------------------ :: AnnoGen
G |- e:A => A ~~> J | z+


G |- e => A ~~> J1 | x+
x : A <: y : B ~~> J2
-------------------------- :: Sub
G |- e <= B ~~> J1;J2 | y-


G |- e => A ~~> J | z+
---------------------- :: SubEqGen
G |- e <= A ~~> J | z+



defn
x : A ; arg ~~> J | z :: :: distapp :: A_
{{ com Distributive application }}
{{ tex [[x]]:[[A]]\,\bullet\,[[arg]]\;\colorbox{lightgray}{$[[~~>]]\;[[J]]\;|\;[[z]]$} }}
by


toplike A
--------------------------- :: Top
x : A ; arg ~~> nothing | z


T = ->|B|
--------------------------- :: Arrow
x : A -> B ; y ~~> code | z


T = \-/|B|
----------------------------------- :: All
x : Forall X*A. B ; Ts ~~> code | z


T = {l : |A|}
---------------------------- :: Rcd
x : {l : A} ; l ~~> code | z


x : A ; arg ~~> J1 | z
x : B ; arg ~~> J2 | z
----------------------------- :: And
x : A & B ; arg ~~> J1;J2 | z


defn
x : A <: y : B ~~> J :: :: cosub :: S_
{{ com Coercive subtyping }}
{{ tex [[x]]:[[A]][[<:]][[y]]:[[B]]\;\colorbox{lightgray}{$[[~~>]][[J]]$} }}
by


ordinary B
toplike B
-------------------------- :: Top
x : A <: y : B ~~> nothing


T = |A|
ordinary A
------------------------- :: Bot
x : Bot <: y : A ~~> code


----------------------- :: Eq
x : A <: y : A ~~> code


T = |Base|
----------------------------- :: Base
x : Base <: y : Base ~~> code


----------------------- :: Var
x : X <: y : X ~~> code


T1 = ->|A2|
T2 = ->|B2|
ordinary B2
x1 : B1 <: y1 : A1 ~~> J1
x2 : A2 <: y2 : B2 ~~> J2
------------------------------------- :: Arrow
x : A1 -> A2 <: y : B1 -> B2 ~~> code


T1 = \-/|A2|
T2 = \-/|B2|
ordinary B2
B1 <: A1
x0 : A2 <: y0 : B2 ~~> J
--------------------------------------------------- :: All
x : Forall X*A1. A2 <: y : Forall X*B1. B2 ~~> code


T1 = {l : |A|}
T2 = {l : |B|}
ordinary B
x0 : A <: y0 : B ~~> J
------------------------------- :: Rcd
x : {l:A} <: y : {l:B} ~~> code


ordinary C
x : A <: y : C ~~> J
------------------------ :: AndL
x : A & B <: y : C ~~> J


ordinary C
x : B <: y : C ~~> J
------------------------ :: AndR
x : A & B <: y : C ~~> J


split B B1 B2
y1 : B1 |> z : B <| y2 : B2 ~~> J3
x : A <: y1 : B1 ~~> J1
x : A <: y2 : B2 ~~> J2
---------------------------------- :: Split
x : A <: z : B ~~> code



defn
x : A |> z : C <| y : B ~~> J :: :: comerge :: M_
{{ com Coercive merging }}
{{ tex [[x]]:[[A]]\;\rhd\;[[z]]:[[C]]\;\lhd\;[[y]]:[[B]]\;\colorbox{lightgray}{$[[~~>]]\;[[J]]$} }}
by


------------------------------------- :: And
z : A |> z : A&B <| z : B ~~> nothing


T = ->|B|
T1 = ->|B1|
T2 = ->|B2|
y1 : B1 |> y : B <| y2 : B2 ~~> J
--------------------------------------------- :: Arrow
x1 : A->B1 |> z : A->B <| x2 : A->B2 ~~> code


T = \-/|B|
T1 = \-/|B1|
T2 = \-/|B2|
y1 : B1 |> y : B <| y2 : B2 ~~> J
------------------------------------------------------------------------ :: All
x1 : Forall X*A. B1 |> z : Forall X*A. B <| x2 : Forall X*A. B2 ~~> code


T = {l : |A|}
T1 = {l : |A1|}
T2 = {l : |A2|}
y1 : A1 |> y : A <| y2 : A2 ~~> J
------------------------------------------------ :: Rcd
x1 : {l:A1} |> z : {l:A} <| x2 : {l:A2} ~~> code
