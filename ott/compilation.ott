grammar

T, Ts :: 'ti_' ::= {{ com Type indices }}
  | Base      ::  :: base  {{ com base type }} {{ tex \mathbb{Z} }}
  | -> T      ::  :: arrow {{ com function type }} {{ tex \overrightarrow{[[T]]} }}
  | \-/ T     ::  :: all   {{ com universal type }} {{ tex [[T]]^\forall }}
  | { l : T } ::  :: rcd   {{ com record type }}
  | T1 & T2   ::  :: and   {{ com intersection type }}
  | | A |     :: M:: translation {{ tex |[[A]]| }}
  | ( A )     :: S:: paren

J, code {{ tex \mathtt{code} }} :: 'js_' ::= {{ com JavaScript statements }}
  | nothing ::  :: empty {{ tex \varnothing }}
  | J1 ; J2 ::  :: concat

p :: 'param_' ::= {{ com parameters }}
  | x : A ::  :: term
  | A     ::  :: type

pm {{ tex ^\pm }} :: 'pm_' ::= {{ com plus/minus }}
  | + ::  :: plus  {{ tex ^+ }}
  | - ::  :: minus {{ tex ^- }}



defns
Compilation :: '' ::=

defn
G |- e mode A ~~> J | z pm :: :: compile :: J_
{{ com Type-directed compilation }} % z- means z is provided (input); z+ means z is generated (output)
by

G |- e mode A ~~> J | z-
--------------------------- :: Gen
G |- e mode A ~~> code | z+


-------------------------------- :: Top
G |- {} => Top ~~> nothing | z-


toplike B
--------------------------------------- :: TopAbs
G |- \x:A. e:B => A->B ~~> nothing | z-


toplike B
-------------------------------------------------------- :: TopTAbs
G |- /\ X * A. e : B => Forall X * A. B ~~> nothing | z-


G |- e => A
toplike A
---------------------------------------- :: TopRcd
G |- {l = e} => {l : A} ~~> nothing | z-


T = |Base|
---------------------------- :: Int
G |- b => Base ~~> code | z-


x : A in G
------------------------- :: Var
G |- x => A ~~> code | z-


x : A in G
------------------------- :: VarGen
G |- x => A ~~> code | z+


G, x:A |- e <= A ~~> J | z-
---------------------------------- :: Fix
G |- fix x:A. e => A ~~> code | z-


T = ->|B|
G, x:A |- e <= B ~~> J | y-
------------------------------------ :: Abs
G |- \x:A. e:B => A->B ~~> code | z-


G |- e1 => A ~~> J1 | x+
G |- e2 => B ~~> J2 | y+
G |- x : A $ y0 : B ~~> J3 | z : C
---------------------------------- :: App
G |- e1 e2 => C ~~> code | z-


T = \-/|B|
G , X * A |- e <= B ~~> J | y-
----------------------------------------------------- :: TAbs
G |- /\ X * A. e : B => Forall X * A. B ~~> code | z-


G |- e => B ~~> J1 | y+
G |- y : B $ A ~~> J2 | z : C
----------------------------- :: TApp
G |- e A => C ~~> J1;J2 | z-


T = {l : |A|}
G |- e => A ~~> J | y+
------------------------------------- :: Rcd
G |- {l = e} => {l : A} ~~> code | z-


G |- e => A ~~> J1 | y+
y : A $ {l} ~~> J2 | z : B
---------------------------- :: Proj
G |- e.l => B ~~> J1;J2 | z-


G |- e1 => A ~~> J1 | z-
G |- e2 => B ~~> J2 | z-
G |- A * B
------------------------------------- :: Merge
G |- e1 ,, e2 => A & B ~~> J1;J2 | z-


G |- e <= A ~~> J | z pm
-------------------------- :: Anno
G |- e:A => A ~~> J | z pm


G |- e1 => A ~~> J1 | y+
G, x:A |- e2 => B ~~> J2 | z-
---------------------------------- :: Def
G |- x = e1; e2 => B ~~> code | z-


G |- e => A ~~> J1 | x+
x : A <:+ y : B ~~> J2
-------------------------- :: Sub
G |- e <= B ~~> J1;J2 | y-


A .=. B
G |- e => A ~~> J | z pm
------------------------ :: SubEquiv
G |- e <= B ~~> J | z pm



defn
G |- x : A $ p ~~> J | z : B :: :: distapp :: A_
{{ com Distributive application }}
by


toplike A
------------------------------------ :: Top
G |- x : A $ p ~~> nothing | z : Top


T = ->|B|
y1 : C <:+ y2 : A ~~> J
---------------------------------------- :: Arrow
G |- x : A -> B $ y : C ~~> code | z : B


G |- A * C
T = \-/|B|
Ts = itoa |C|
-------------------------------------------------- :: All
G |- x : Forall X*A. B $ C ~~> code | z : B [X~>C]


G |- x : A $ p ~~> J1 | z : A'
G |- x : B $ p ~~> J2 | z : B'
-------------------------------------- :: And
G |- x : A&B $ p ~~> J1;J2 | z : A'&B'



defn
x : A $ { l } ~~> J | z : B :: :: distproj :: P_
{{ com Distributive projection }}
by


toplike A
--------------------------------- :: Top
x : A $ {l} ~~> nothing | z : Top


T = {l : |A|}
---------------------------------- :: RcdEq
x : {l : A} $ {l} ~~> code | z : A


l1 <> l2
T = {l : |A|}
----------------------------------------- :: RcdNeq
x : {l1 : A} $ {l2} ~~> nothing | z : Top


x : A $ {l} ~~> J1 | z : A'
x : B $ {l} ~~> J2 | z : B'
----------------------------------- :: And
x : A&B $ {l} ~~> J1;J2 | z : A'&B'



defn
x : A <: pm y : B ~~> J :: :: cosub :: S_
{{ com Coercive subtyping }} % x:A <:+ ... means x is exactly of type A (not derive from S-And{L,R})
by


toplike B
---------------------------- :: Top
x : A <:pm y : B ~~> nothing


T = |A|
--------------------------- :: Bot
x : Bot <:pm y : A ~~> code


A .=. B
------------------------ :: Equiv
x : A <:+ y : B ~~> code


T = |Base|
------------------------------- :: Int
x : Base <:pm y : Base ~~> code


------------------------- :: Var
x : X <:pm y : X ~~> code


T1 = ->|A2|
T2 = ->|B2|
x1 : B1 <:+ y1 : A1 ~~> J1
x2 : A2 <:+ y2 : B2 ~~> J2
--------------------------------------- :: Arrow
x : A1 -> A2 <:pm y : B1 -> B2 ~~> code


T1 = \-/|A2|
T2 = \-/|B2|
B1 <: A1
x0 : A2 <:+ y0 : B2 ~~> J
----------------------------------------------------- :: All
x : Forall X*A1. A2 <:pm y : Forall X*B1. B2 ~~> code


T1 = {l : |A|}
T2 = {l : |B|}
x0 : A <:+ y0 : B ~~> J
--------------------------------- :: Rcd
x : {l:A} <:pm y : {l:B} ~~> code


x : A <:- y : C ~~> J
-------------------------- :: AndL
x : A & B <:pm y : C ~~> J


x : B <:- y : C ~~> J
-------------------------- :: AndR
x : A & B <:pm y : C ~~> J


split B B1 B2
y1 : B1 |> z : B <| y2 : B2 ~~> J3
x : A <:pm y1 : B1 ~~> J1
x : A <:pm y2 : B2 ~~> J2
---------------------------------- :: Split
x : A <:pm z : B ~~> code



defn
x : A |> z : C <| y : B ~~> J :: :: comerge :: M_
{{ com Coercive merging }}
by


------------------------------------- :: And
z : A |> z : A&B <| z : B ~~> nothing


T = ->|B|
T1 = ->|B1|
T2 = ->|B2|
y1 : B1 |> y : B <| y2 : B2 ~~> J
--------------------------------------------- :: Arrow
x1 : A->B1 |> z : A->B <| x2 : A->B2 ~~> code


T = \-/|B|
T1 = \-/|B1|
T2 = \-/|B2|
y1 : B1 |> y : B <| y2 : B2 ~~> J
------------------------------------------------------------------------ :: All
x1 : Forall X*A. B1 |> z : Forall X*A. B <| x2 : Forall X*A. B2 ~~> code


T = {l : |A|}
T1 = {l : |A1|}
T2 = {l : |A2|}
y1 : A1 |> y : A <| y2 : A2 ~~> J
------------------------------------------------ :: Rcd
x1 : {l:A1} |> z : {l:A} <| x2 : {l:A2} ~~> code
