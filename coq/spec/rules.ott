%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar var, x , y ::= {{ repr-locally-nameless }}

metavar lit, b ::= {{ coq nat }}

metavar label, i, l ::= {{ coq string }}

% metavar tlabel, ll ::= {{ coq string }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR (LNgen portion)

grammar

typ, A, B, C :: 'typ_' ::= {{ com types }}
  | Top            ::  :: top     {{ com top type }} {{ tex \top }}
  | Bot            ::  :: bot     {{ com bottom type }} {{ tex \bot }}
  | Base           ::  :: base    {{ com base type }} {{ tex \mathbb{B} }}
  | A -> B         ::  :: arrow   {{ com function types }}
  | A & B          ::  :: and     {{ com intersection }}
  | { l : A }      ::  :: rcd     {{ com record }}
  | ( A )          :: S:: paren   {{ coq [[A]] }}
  % | Int       :: M:: int     {{ com int }} {{ tex \mathsf{Int}  }}
  % | Bool      :: M:: bool    {{ com bool}} {{ tex \mathsf{Bool} }}


exp, e :: 'exp_' ::= {{ com expressions }}
  | top              ::  :: top    {{ com top value }} {{ tex \top }}
  | b                ::  :: base   {{ com base literal }} {{ tex b }}
  | x                ::  :: var     {{ com variables }}
  | \ x : A . e : B
                     ::  :: abs     (+ bind x in e +)
                                  {{ com abstractions }}
	                          {{ tex [[\]][[x]].\,[[e]][[:]][[A]][[->]][[B]] }}
  | fix x : A . e    ::  :: fixpoint
                                  (+ bind x in e +)
                                  {{ com fixpoint }}
                                  {{ tex [[fix]]~[[x]].\,[[e]][[:]][[A]] }}
  | e1 e2                           ::  :: app     {{ com applications }}
  | e1 ,, e2                ::  :: merge   {{ com merge }}
  | e : A                           ::  :: anno    {{ com annotation }}
  | { l = e }        ::  :: rcd    {{ com record }}
  | e . l                           ::  :: proj    {{ com projection }}
  | e1 [ x ~> e2 ]                  :: M:: subst   {{ coq (open_exp_wrt_exp [[x e1]][[e2]]) }}
  | [ e <-- x ]                     :: M:: close   {{ coq (close_exp_wrt_exp [[x]] [[e]]) }}
  | ( e )                           :: S:: paren   {{ coq ([[e]]) }}

substitutions
  single exp x   :: esubst

freevars
  exp x      :: fv

parsing
  typ_arrow <= typ_and
  typ_arrow right typ_arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR  (non LNgen portion)

grammar

ctx, G {{ tex \Gamma }} :: 'ctx_' ::= {{ com typing context }} {{ coq list ( atom * typ ) }}
  | []           ::  :: empty      {{ coq nil }}
                                   {{ tex \cdot }}
                                   {{ com empty context }}
  | G , x : A    ::  :: cons       {{ coq (cons ([[x]],[[A]]) [[G]]) }}
                                   {{ com assumption }}
                                   
dirflag :: '' ::= {{ com checking direction }}
  | =>             ::   :: Inf
  | <=             ::   :: Chk

terminals :: 'terminals_' ::=
  | \            ::  :: lambda     {{ tex \lambda }}
  | ~>           ::  :: subst      {{ tex \mapsto }}
  | ~>>          ::  :: subst2     {{ tex \mapsto }}
  | ->           ::  :: arrow      {{ tex \rightarrow }}
  | -->          ::  :: longarrow  {{ tex \rightrightarrows }}
  | |->          ::  :: red        {{ tex \longmapsto }}
  | <=           ::  :: check      {{ tex \Leftarrow }}
  | =>           ::  :: infer      {{ tex \Rightarrow }}
  | |-           ::  :: turnstile  {{ tex \vdash }}
  | |=           ::  :: dash2      {{ tex \models }}
  | T            ::  :: t          {{ tex \top }}
  | Top          ::  :: top        {{ tex \mathsf{Top}  }}
  | int          ::  :: int        {{ tex \mathsf{Int}  }}
  | ,,           ::  :: Merge      {{ tex \,,,\, }}
  | &            ::  :: And        {{ tex \, \& \, }}
  | :            ::  :: Typ        {{ tex : }}
  | in           ::  :: in         {{ tex \in }}
  | ;            ::  :: ctxAnd     {{ tex ; }}
  | ,            ::  :: break      {{ tex , }}
  | split        ::  :: split      {{ tex \mathsf{Split} }}
  | ordinary     ::  :: ordinary   {{ tex \mathsf{Ordinary} }}
  | topLike      ::  :: topLike    {{ tex \mathsf{TOPLIKE} }}
  | <*>          ::  :: disjointSpec    {{ tex ** }}
  | *            ::  :: disjoint        {{ tex * }}
  | ~            ::  :: consistencySpec {{ tex \approx }}
  | ~~           ::  :: consistent {{ tex \approx\approx }}
  | <            ::  :: val2exprl  {{ tex \langle}}
  | >            ::  :: val2exprr  {{ tex \rangle}}
  | topl         ::  :: topl       {{ tex \rceil }}
  | topr         ::  :: topr       {{ tex \lceil }}
  | fix          ::  :: fixpoint   {{ tex \mathsf{fix} }}
  | >->          ::  :: stepalt    {{ tex \rightarrow }}
  | >->*         ::  :: stepmul    {{ tex \rightarrow^{*} }}
  | ~~>          ::  :: sarrow     {{ tex \rightsquigarrow }}
  | |>           ::  :: rhd        {{ tex \rhd }}
  | <|           ::  :: lhd        {{ tex \lhd }}
  | ~=           ::  :: equ        {{ tex \approx }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | not formula              :: M :: not
    {{ tex \neg [[formula]] }}
    {{ coq not ([[formula]]) }}
  | formula1 or formula2              :: M :: or
    {{ tex [[formula1]]~\lor~[[formula2]] }}
    {{ coq ([[formula1]] \/ [[formula2]]) }}
  | formula1 and formula2             :: M :: and
    {{ tex [[formula1]]~\land~[[formula2]] }}
    {{ coq ([[formula1]] /\ [[formula2]]) }}
  | ( formula )              :: M :: brackets
    {{ tex ([[formula]]\!) }}
    {{ coq [[formula]] }}
  | uniq G                   ::   :: uniqG
    {{ coq uniq [[G]] }}
    {{ tex }}
  | x : A in G               ::   :: inG
    {{ coq binds [[x]][[A]][[G]] }}
  | x notin fv e             ::   :: fresh
    {{ coq [[x]] \notin fv[[e]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}
    {{ tex [[x]] \notin [[G]] }}
  | l1 <> l2                 ::   :: label
    {{ coq [[l1]] <> [[l2]] }}
    {{ tex [[l1]] \neq [[l2]] }}
  | A <*> B                  :: M :: disjointSpec
    {{ coq disjointSpec[[A]][[B]] }}
  | v1 ~ v2                  :: M :: consistencySpec
    {{ coq consistencySpec[[v1]][[v2]] }}
    {{ tex \mathsf{consistencySpec}~[[v1]]~[[v2]] }}
  | e1 --> i e2               :: M :: multistep
    {{ coq (star exp step)[[i]][[e1]][[e2]] }}
    {{ tex [[e1]]~[[-->]][[i]]~[[e2]] }}
  | lookup ll tv => t         :: M :: lookupLabel
    {{ coq tlookup [[ll]] [[tv]] = Some [[t]] }}
  | lookup ll At => Bt        :: M :: lookupLabelTyp
    {{ coq Tlookup [[ll]] [[At]] = Some [[Bt]] }}
  | lookup ll At =/>          :: M :: lookupLabelTypNone
    {{ coq Tlookup [[ll]] [[At]] = None }}
  | x : At in Gt              ::   :: inGt
    {{ coq binds [[x]][[At]][[Gt]] }}
  | uniq Gt                   ::   :: uniqGt
    {{ coq uniq [[Gt]] }}
    {{ tex }}
  | t >->* t'             ::  :: steps


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
embed
{{ coq
Fixpoint type2index (A: typ) : tindex :=
  match A with
  | typ_base => ti_base
  | typ_arrow _ A' => ti_arrow (type2index A')
  | typ_rcd l A' => ti_rcd l (type2index A')
  | typ_and A1 A2 => ti_and (type2index A1) (type2index A2) (* needs sorting and filtering toplike types *)
  | _ => ti_base (* should not fall into this case *)
  end.

Fixpoint typeindex2string (T: tindex) : string :=
  match T with
  | ti_base => "Base"
  | ti_arrow T' => "->"++ typeindex2string T'
  | ti_rcd l T' => "{" ++  l ++ ":" ++  typeindex2string T' ++ "}"
  | ti_and T1 T2 => typeindex2string T1 ++ "&" ++ typeindex2string T2
  | ti_string s => s
end.

Definition typeindex2label (T: tindex) : label := (typeindex2string T).
}}

defns
TopLikeType :: '' ::=

  defn
  toplike A :: :: toplike :: TL_
  {{ com Top-like Types }}
  {{ tex [[topl]][[A]][[topr]] }}
  by


  ---------------- :: top
  toplike Top

  toplike A
  toplike B
  ---------------- :: and
  toplike A & B

  toplike B
  ---------------- :: arr
  toplike A -> B

  toplike B
  ---------------- :: rcd
  toplike {l:B}


defns
EqIndexType :: '' ::=

  defn
  A ~= B :: :: eqIndTyp :: EI_
  {{ com Types with the same index }}
  by

  A ~= B
  B ~= C
  --------------- :: trans
  A ~= C

  B ~= A
  --------------- :: symm
  A ~= B
  
  ---------------- :: arrow
  A1->B ~= A2->B

  A ~= B
  --------------- :: rcd
  {l:A} ~= {l:B}

  --------------- :: comm
  A&B ~= B&A

  -------------------- :: assoc
  A&(B&C) ~= (A&B)&C

  toplike A
  --------------- :: top
  A&B ~= B

  A1 ~= A2
  -------------------- :: dup
  (A1&A2)&B ~= A1&B
  
  
defns
SplitType :: '' ::=

  defn
  split A B C :: :: spl :: Sp_
  {{ com Split a Type into Two }}
  {{ tex [[B]] \lhd\,[[A]]\,\rhd [[C]] }}
  by


  ----------------:: and
  split (A&B) (A) (B)


  split B B1 B2
  ----------------------------- :: arrow
  split (A->B) (A->B1) (A->B2)


  split B B1 B2
  -------------------------- :: rcd
  split {l:B} {l:B1} {l:B2}



defns
OrdinaryType :: '' ::=

  defn
  ordinary A :: :: ord :: O_
  {{ com Ordinary Types }}
  {{ tex [[A]]~[[ordinary]] }}
  by


  ---------------- :: top
  ordinary Top


  ---------------- :: int
  ordinary Base


  ordinary B
  ---------------- :: arrow
  ordinary A->B


  ordinary B
  ---------------- :: rcd
  ordinary {l:B}



defns
Disjoint :: '' ::=

  defn A * B :: :: disjoint    :: 'D_'
  {{ com Type Disjointness (Algorithmic) }}
  by


  --------------- :: topL
  Top * A


  ------------------ :: topR
  A * Top


  A1 * B
  A2 * B
  --------------- :: andL
  A1 & A2 * B


  A * B1
  A * B2
  --------------- :: andR
  A * B1 & B2


  ---------------------- :: BaseArr
  Base * A1 -> A2


  ---------------------- :: ArrBase
  A1 -> A2 * Base


  A2 * B2
  ---------------------- :: ArrArr
  A1 -> A2 * B1 -> B2


  A * B
  ------------------------ :: rcdEq
  { l : A } * { l : B }


  l1 <> l2
  ------------------------- :: rcdNeq
  { l1 : A } * { l2 : B }


  ---------------------- :: BaseRcd
  Base * { l : A }


  ---------------------- :: RcdBase
  { l : A } * Base


  ---------------------- :: ArrRcd
  A1 -> A2 * { l : A }


  ---------------------- :: RcdArr
  { l : A } * A1 -> A2


defns
CoMerge :: '' ::=

  defn
  t1 : A |> C <| t2 : B ~~> t :: :: comerge :: M_
  {{ com Coercive merging }}
  by
  ---------------------------------------- :: And
  t1 : A |> A&B <| t2 : B ~~> t1 ; t2

  (t1.->|B1|) x : B1 |> B <| (t2.->|B2|) x : B2 ~~> t
  ------------------------------------------------------------- :: Arrow
  t1 : A->B1 |> A->B <| t2 : A->B2 ~~> { ->|B| => \ x . t }

  t1.{l:|A1|} : A1 |> A <| t2.{l:|A2|} : A2 ~~> t
  --------------------------------------------------------------- :: Rcd
  t1 : {l:A1} |> {l:A} <| t2 : {l:A2} ~~> {{l:|A|} => t }


defns
CoSubtyping :: '' ::=

  defn
  t1 : A <: B ~~> t2 :: :: cosub :: S_
  {{ com Coercive subtyping }}
  by

  ordinary B
  toplike B
  -------------------------- :: Top
  t : A <: B ~~> {}
  
  ordinary B
  not toplike B
  ------------------------------------- :: Bot
  t : Bot <: B ~~> { |B| => fix x . x }

  ------------------------------------ :: Base
  t : Base <: Base ~~> {|Base|=> t.|Base|}

  ordinary B2
  not toplike B2
  x : B1 <: A1 ~~> t1 and (t.->|A2|) t1 : A2 <: B2 ~~> t2
  -------------------------------------------------------------------- :: Arrow
  t : A1 -> A2 <: B1 -> B2 ~~> { ->|B2| => \x.t2 }

  ordinary B
  not toplike B
  t.{l : |A|} : A <: B ~~> t2
  ---------------------------------------------- :: Rcd
  t : {l:A} <: {l:B} ~~> {{l : |B|} => t2 }

  ordinary C
  t : A <: C ~~> t'
  ------------------------ :: AndL
  t : A & B <: C ~~> t'

  ordinary C
  t : B <: C ~~> t'
  ------------------------ :: AndR
  t : A & B <: C ~~> t'

  split B B1 B2
  t : A <: B1 ~~> t1
  t : A <: B2 ~~> t2
  t1 : B1 |> B <| t2 : B2 ~~> t3
  -------------------------------- :: Split
  t : A <: B ~~> t3



defns
ApplicativeDistribution :: '' ::=

  defn
  A |> B :: :: appdist :: AD_
  {{ com Applicative distribution }}
  {{ tex [[A]] \rhd [[B]] }}
  by

  ---------------- :: Arrow
  A -> B |> A -> B

  ----------------- :: TopArrow
  Top |> Top -> Top

  A |> A1 -> A2
  B |> B1 -> B2
  --------------------------- :: AndArrow
  A & B |> A1 & B1 -> A2 & B2

  ------------------ :: Rcd
  {l : A} |> {l : A}

  ---------------- :: TopRcd
  Top |> {l : Top}

  A |> {l : A'}
  B |> {l : B'}
  ---------------------- :: AndRcd
  A & B |> {l : A' & B'}


defns
DistributiveApplication :: '' ::=

  defn
  t1 : A ; tvl ~~> t3 :: :: distapp :: A_
  {{ com Distributive application }}
  by

  toplike A
  ---------------------------- :: Top
  t1 : A ; t2 ~~> { }

  ------------------------------------ :: Arrow
  t1 : A -> B ; t2 ~~> (t1.|A->B|) t2

  ----------------------------------------- :: Rcd
  t : {l : A} ; { l } ~~> t.{l : |A|}

  t : A ; t2 ~~> t1
  t : B ; t2 ~~> t2
  ------------------------------ :: And
  t : A & B ; t2 ~~> t1; t2


defns
Elaboration :: '' ::=

  defn
  G |- e dirflag A ~~> t
  :: :: elaboration :: 'Ela_'
  {{ com Elaboration }}
  by

  uniq G
  -------------------------------- :: Top
  G |- top => Top ~~> {}


  uniq G
  toplike B
  --------------------------------------- :: TopAbs
  G |- \x:A. e:B => A->B ~~> {}


  G |- e => A ~~> t
  toplike A
  ---------------------------------------- :: TopRcd
  G |- {l = e} => {l : A} ~~> {}


  uniq G
  ------------------------------ :: Base
  G |- b => Base ~~> { |Base| => b }


  uniq G
  x : A in G
  --------------------------- :: Var
  G |- x => A ~~> x


  G, x:A |- e <= A ~~> t
  ----------------------------------------------------- :: Fix
  G |- fix x:A. e => A ~~> fix x . t


  G, x:A |- e <= B ~~> t
  ----------------------------------------- :: Abs
  G |- \x:A. e:B => A->B ~~> {->|B| =>\x.t}


  G |- e1 => A ~~> t1
  A |> B -> C
  G |- e2 <= B ~~> t2
  t1 : A ; t2 ~~> t3
  ----------------------------------------- :: App
  G |- e1 e2 => C ~~> t3


  G |- e => A ~~> t
  ------------------------------------------------- :: Rcd
  G |- {l = e} => {l : A} ~~> { {l : |A|} => t }


  G |- e => A ~~> t1
  A |> {l : B}
  t1 : A ; {l} ~~> t2
  ------------------------------------------------- :: Proj
  G |- e.l => B ~~> t2


  G |- e1 => A ~~> t1
  G |- e2 => B ~~> t2
  A * B
  ------------------------------------- :: Merge
  G |- e1 ,, e2 => A & B ~~> t1;t2


  G |- e <= A ~~> t
  ------------------------ :: Anno
  G |- e:A => A ~~> t


  G |- e => A ~~> t1
  t1 : A <: B ~~> t2
  -------------------------- :: Sub
  G |- e <= B ~~> t2
