@precedence {
  times @left,
  plus  @left,
  comp  @left,
  and   @right,
  or    @right,
  merge @left,
  forward @right,
  intersect @left,
  arrow @right
}

@top Program { (definition ";")* expression }

definition { TypeDef | kw<"def"> TermDef }

TypeDef {
  kw<"type"> TypeNameDef angles<TypeNameDef>* (kw<"extends"> type)? "=" type
}

TermDef {
  kw<"override">? TermNameDef typeParam* termParam* "=" expression
}

PatternDef {
  kw<"override">? parens<TermNameDef termParam* SelfAnno?> "." TermDef
}

typeParam { TypeNameDef | brackets<TypeNameDef "*" type> }
termParam { TermNameDef | parens<TermNameDef ":" type> }
SelfAnno { "[" TermNameDef ":" type "]" }

type {
  btype | kw<"forall"> typeParam+ "." type |
  type !arrow TypeOp<"->"> type |
  type !intersect TypeOp<"&"> type
}

btype { btype? atype }

atype {
  TypeName angles<typeSepByComma>* |
  kW<"Int"> | kW<"Double"> | kW<"String"> | kW<"Bool"> | kW<"Top"> | kW<"Bot"> |
  TraitType { kW<"Trait"> brackets<typeSepByComma> } |
  RecordType { braces<endByCommaOrSemi<LabelDecl ":" type>> } |
  parens<type>
}

expression {
  opexp ~conflict (":" type)? |
  kw<"trait"> SelfAnno? (kw<"implements"> type)? (kw<"inherits"> opexp)? "=>" opexp
}

opexp {
  lexp | minus opexp | LogicOp<"!"> opexp |
  opexp !times ArithOp<"*" | "/" | "%"> opexp |
  opexp !plus (ArithOp<"+"> | minus) opexp |
  opexp !comp CompareOp opexp |
  opexp !and LogicOp<"&&"> opexp |
  opexp !or  LogicOp<"||"> opexp |
  opexp !merge MergeOp opexp |
  opexp !forward ForwardOp opexp
}

lexp {
  fexp | Lambda { "\\" termParam+ "->" expression } |
  BigLambda { "/\\" typeParam+ "." expression } |
  Let { kw<"let"> TermNameDef "=" expression kw<"in"> expression } |
  LetRec { kw<"letrec"> TermNameDef ":" type "=" expression kw<"in"> expression } |
  Open { kw<"open"> expression kw<"in"> expression } |
  IfElse { kw<"if"> expression kw<"then"> expression kw<"else"> expression } |
  New { kw<"new"> expression }
}

fexp { fexp? aexp }

aexp {
  TermName | Number | String | Unit |
  Boolean { kw<"true"> | kw<"false"> } | Undefined { kw<"undefined"> } |
  aexp "." TermName | aexp "@" atype | aexp "\\" RecordType |
  Record { braces<endByCommaOrSemi<TermDef | PatternDef>> } |
  parens<expression>
}

kw<word> { @specialize[name={word}]<lowerid, word> }
kW<word> { @specialize[name={word}]<upperid, word> }

braces<contents> { "{" contents "}" }
parens<contents> { "(" contents ")" }
brackets<contents> { "[" contents "]" }
angles<contents> { "<" contents ">" }

endByCommaOrSemi<stmt> { (stmt ("," | ";"))* }
typeSepByComma { type | type "," type }

TypeName { upperid }
TypeNameDef { upperid }
TermName { lowerid }
TermNameDef { lowerid }
LabelDecl { lowerid }

@skip { whitespace | LineComment | BlockComment }

@tokens {

  whitespace { std.whitespace+ }

  LineComment { "--" ![\n]* }

  BlockComment { "{-" blockCommentRest }
  blockCommentRest { "-" blockCommentAfterHyphen | ![-] blockCommentRest }
  blockCommentAfterHyphen { "}" | blockCommentRest }

  identifierChar { std.asciiLetter | std.digit | "'" }
  lowerid { std.asciiLowercase identifierChar* }
  upperid { std.asciiUppercase identifierChar* }

  octit { $[0-7] }
  hexit { std.digit | $[a-fA-F] }
  Number {
    std.digit+ ("." std.digit+)? (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" hexit+ | "0X" hexit+ |
    "0o" octit+ | "0O" octit+
  }

  String { '"' (![\\\n"] | "\\" _)* '"'? }

  Unit { "()" }

  "(" ")" "{" "}" "[" "]" "<" ">"
  "." "," ";" ":" "*" "\\" "/\\" "@" "^"
  "=" "->" "=>"[name=TraitArrow]

  TypeOp<op> { op }
  ArithOp<op> { op }
  LogicOp<op> { op }
  CompareOp { "<" "="? | ">" "="? | "==" | "!=" }
  MergeOp { ",," }
  ForwardOp { "^" }

  minus[name=ArithOp] { "-" }

  @precedence { LineComment, minus }

  @precedence { BlockComment, "{" }

  @precedence { CompareOp, "<" }

}
