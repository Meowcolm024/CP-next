@precedence {
  times @left,
  plus  @left,
  comp  @left,
  and   @right,
  or    @right,
  merge @left,
  forward @right,
  intersect @left,
  arrow @right
}

@top Program { ~conflict (definition ";")* expression }

definition { TypeDef | TermDef }

TypeDef {
  kw<"type"> TypeNameDecl angles<TypeNameDecl>* TypeNameDecl* (kw<"extends"> type)? "=" type
}

TermDef {
  TermNameDecl ~conflict typeParam* termParam* (":" type)? "=" expression
}

type {
  btype | kw<"forall"> typeParam+ "." type |
  kW<"Trait"> typeWithPercent |
  type !arrow TypeOp<"->"> type |
  type !intersect TypeOp<"&"> type
}

btype { atype (atype | angles<typeWithPercent>)* }

atype {
  TypeName | RecordType { braces<sepEndBySemi<LabelDecl ":" type>> } |
  kW<"Int"> | kW<"Double"> | kW<"String"> | kW<"Bool"> | kW<"Top"> | kW<"Bot"> |
  parens<type>
}

expression { opexpr ~conflict (":" type)? }

opexpr {
  lexpr | minus opexpr | LogicOp<"!"> opexpr |
  opexpr !times (ArithOp<"*" | "/"> | modulo) opexpr |
  opexpr !plus (ArithOp<"+"> | minus) opexpr |
  opexpr !comp CompareOp opexpr |
  opexpr !and LogicOp<"&&"> opexpr |
  opexpr !or  LogicOp<"||"> opexpr |
  opexpr !merge MergeOp opexpr |
  opexpr !forward ForwardOp opexpr
}

lexpr {
  fexpr | Lambda { "\\" termParam+ "->" expression } |
  BigLambda { "/\\" typeParam+ "." expression } |
  Let { kw<"let"> TermNameDecl "=" expression kw<"in"> expression } |
  LetRec { kw<"letrec"> TermNameDecl ":" type "=" expression kw<"in"> expression } |
  Open { kw<"open"> expression kw<"in"> expression } |
  IfElse { kw<"if"> expression kw<"then"> expression kw<"else"> expression } |
  Trait { kw<"trait"> SelfAnno? (kw<"implements"> type)? (kw<"inherits"> opexpr)? "=>" opexpr } |
  New { kw<"new"> expression } | ToString { kw<"toString"> fexpr }
}

fexpr {
  aexpr (aexpr | "@" atype)* | aexpr "." Label | aexpr "\\" RecordType
}

aexpr {
  TermName | Number | String | Unit |
  kw<"true"> | kw<"false"> | kw<"undefined"> |
  Record { braces<sepEndBySemi<kw<"override">? (RecordField | MethodPattern)>> } |
  parens<expression>
}

RecordField {
  LabelDecl termParam* "=" expression
}

MethodPattern {
  parens<LabelDecl termParam* SelfAnno?> "." RecordField
}

typeParam { underscore | TypeNameDecl | parens<TypeNameDecl "*" type> }
termParam { underscore | TermNameDecl | parens<TermNameDecl ":" type> }
SelfAnno { brackets<TermNameDecl ":" type> }

kw<word> { @specialize[name={word}]<lowerid, word> }
kW<word> { @specialize[name={word}]<upperid, word> }

braces<contents> { "{" contents "}" }
parens<contents> { "(" contents ")" }
brackets<contents> { "[" contents "]" }
angles<contents> { "<" contents ">" }

sepEndBySemi<clause> { ~conflict (clause ";")* clause? }
typeWithPercent { type ~conflict ("%" type)? }

TypeNameDecl { upperid }
TypeName { upperid }
TermNameDecl { lowerid }
TermName { lowerid | upperid }
LabelDecl { lowerid | upperid }
Label { lowerid | upperid }

@skip { whitespace | LineComment | BlockComment }

@tokens {

  whitespace { std.whitespace+ }

  LineComment { "--" ![\n]* }

  BlockComment { "{-" blockCommentRest }
  blockCommentRest { "-" blockCommentAfterHyphen | ![-] blockCommentRest }
  blockCommentAfterHyphen { "}" | blockCommentRest }

  underscore { "_" }
  idChar { std.asciiLetter | std.digit | underscore | "'" }
  lowerid { std.asciiLowercase idChar* }
  upperid { std.asciiUppercase idChar* }

  octit { $[0-7] }
  hexit { std.digit | $[a-fA-F] }
  Number {
    std.digit+ ("." std.digit+)? (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" hexit+ | "0X" hexit+ |
    "0o" octit+ | "0O" octit+
  }

  String { '"' (![\\\n"] | "\\" _)* '"'? }

  Unit { "()" }

  "(" ")" "{" "}" "[" "]" "<" ">"
  "." "," ";" ":" "*" "\\" "/\\" "@" "^" "%"
  "=" "->" "=>"[name=TraitArrow]

  TypeOp<op> { op }
  ArithOp<op> { op }
  LogicOp<op> { op }
  CompareOp { "<" "="? | ">" "="? | "==" | "!=" }
  MergeOp { "," }
  ForwardOp { "^" }

  minus[name=ArithOp] { "-" }
  modulo[name=ArithOp] { "%" }

  @precedence { LineComment, minus }
  @precedence { BlockComment, "{" }
  @precedence { CompareOp, "<" }
  @precedence { modulo, "%" }

}
