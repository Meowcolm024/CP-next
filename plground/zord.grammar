@precedence {
  times @left,
  plus  @left,
  comp  @left,
  and   @right,
  or    @right,
  merge @left,
  forward @right,
  intersect @left,
  arrow @right
}

@top Program { (definition ";")* expression }

definition { TypeDef | TermDef }

TypeDef {
  kw<"type"> TypeNameDef angles<TypeNameDef>* TypeNameDef* (kw<"extends"> type)? "=" type
}

TermDef {
  kw<"def"> TermNameDef ("@" typeParam)* termParam* (":" type)? "=" expression
}

type {
  btype | kw<"forall"> typeParam+ "." type |
  kw<"Trait"> typeWithPercent |
  type !arrow TypeOp<"->"> type |
  type !intersect TypeOp<"&"> type
}

btype { atype (atype | angles<typeWithPercent>)* }

atype {
  TypeName | RecordType { braces<sepEndBySemi<LabelDecl ":" type>> } |
  kw<"Int"> | kw<"Double"> | kw<"String"> | kw<"Bool"> | kw<"Top"> | kw<"Bot"> |
  parens<type>
}

expression { opexpr ~conflict (":" type)? }

opexpr {
  lexpr | minus opexpr | LogicOp<"!"> opexpr |
  opexpr !times (ArithOp<"*" | "/"> | modulo) opexpr |
  opexpr !plus (ArithOp<"+"> | minus) opexpr |
  opexpr !comp CompareOp opexpr |
  opexpr !and LogicOp<"&&"> opexpr |
  opexpr !or  LogicOp<"||"> opexpr |
  opexpr !merge MergeOp opexpr |
  opexpr !forward ForwardOp opexpr
}

lexpr {
  fexpr | Lambda { "\\" termParam+ "->" expression } |
  BigLambda { "/\\" typeParam+ "." expression } |
  Let { kw<"let"> TermNameDef "=" expression kw<"in"> expression } |
  LetRec { kw<"letrec"> TermNameDef ":" type "=" expression kw<"in"> expression } |
  Open { kw<"open"> expression kw<"in"> expression } |
  IfElse { kw<"if"> expression kw<"then"> expression kw<"else"> expression } |
  Trait { kw<"trait"> SelfAnno? (kw<"implements"> type)? (kw<"inherits"> opexpr)? "=>" opexpr } |
  New { kw<"new"> expression }
}

fexpr {
  aexpr (aexpr | "@" atype)* |
  aexpr "." TermName |
  aexpr "\\" RecordType
}

aexpr {
  TermName | Number | String | Unit |
  kw<"true"> | kw<"false"> | kw<"undefined"> |
  Record { braces<sepEndBySemi<kw<"override">? (RecordField | MethodPattern)>> } |
  parens<expression>
}

RecordField {
  TermNameDef termParam* "=" expression
}

MethodPattern {
  parens<TermNameDef termParam* SelfAnno?> "." RecordField
}

typeParam { TypeNameDef | brackets<TypeNameDef "*" type> }
termParam { TermNameDef | parens<TermNameDef ":" type> }
SelfAnno { "[" TermNameDef ":" type "]" }

kw<word> { @specialize[name={word}]<identifier, word> }

braces<contents> { "{" contents "}" }
parens<contents> { "(" contents ")" }
brackets<contents> { "[" contents "]" }
angles<contents> { "<" contents ">" }

sepEndBySemi<clause> { ~conflict (clause ";")* clause? }
typeWithPercent { type ~conflict ("%" type)? }

TypeName { identifier }
TypeNameDef { identifier }
TermName { identifier }
TermNameDef { identifier }
LabelDecl { identifier }

@skip { whitespace | LineComment | BlockComment }

@tokens {

  whitespace { std.whitespace+ }

  LineComment { "--" ![\n]* }

  BlockComment { "{-" blockCommentRest }
  blockCommentRest { "-" blockCommentAfterHyphen | ![-] blockCommentRest }
  blockCommentAfterHyphen { "}" | blockCommentRest }

  idStart { std.asciiLetter | "_" }
  idChar { std.asciiLetter | std.digit | "'" | "_" }
  identifier { idStart idChar* }

  octit { $[0-7] }
  hexit { std.digit | $[a-fA-F] }
  Number {
    std.digit+ ("." std.digit+)? (("e" | "E") ("+" | "-")? std.digit+)? |
    "0x" hexit+ | "0X" hexit+ |
    "0o" octit+ | "0O" octit+
  }

  String { '"' (![\\\n"] | "\\" _)* '"'? }

  Unit { "()" }

  "(" ")" "{" "}" "[" "]" "<" ">"
  "." "," ";" ":" "*" "\\" "/\\" "@" "^" "%"
  "=" "->" "=>"[name=TraitArrow]

  TypeOp<op> { op }
  ArithOp<op> { op }
  LogicOp<op> { op }
  CompareOp { "<" "="? | ">" "="? | "==" | "!=" }
  MergeOp { "," }
  ForwardOp { "^" }

  minus[name=ArithOp] { "-" }
  modulo[name=ArithOp] { "%" }

  @precedence { LineComment, minus }
  @precedence { BlockComment, "{" }
  @precedence { CompareOp, "<" }
  @precedence { modulo, "%" }

}
