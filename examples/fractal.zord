--| Pass

open doc;
open svg;

type DocSig'<Element><Graphic> extends DocSig<Element> = {
  Graph : { width: Int; height: Int } -> Graphic -> Element
};

html' = trait implements DocSig'<HTML><HTML> inherits html => {
  (Graph {..} e).html = "<svg width=\"" ++ toString width ++ "\" height=\"" ++ toString height ++ "\">" ++ e.html ++ "</svg>"
};

fold' T (f : T -> T -> T) (z : T) (xs : [T]) (i : Int) : T =
  if i == 0 then z else f (fold' @T f z xs (i-1)) (xs!!(i-1));
fold T (f : T -> T -> T) (z : T) (xs : [T]) = fold' @T f z xs (#xs);

type Draw Graphic Color = {
  init : { x: Int; y: Int; width: Int; height: Int; color: Color; level: Int };
  draw : { x: Int; y: Int; width: Int; height: Int; level: Int } -> Graphic;
};

doc T C = trait [self : DocSig'<T><T> & GraphicSig<T><C> & ColorSig<C> & Draw T C] implements Draw T C => {
  init = { x = 0; y = 0; width = 600; height = 600; color = new Black; level = 3 };
  draw = \{..} ->
    let center = new Rect { x = x + width/3; y = y + height/3; width = width/3; height = height/3; color = new White } in
    if level == 0 then center else
      let opt = { width = width/3; height = height/3; level = level - 1 } in
      let arr = [
        draw (opt,{ x = x; y = y });
        draw (opt,{ x = x + width/3; y = y });
        draw (opt,{ x = x + width*2/3; y = y });
        draw (opt,{ x = x; y = y + height/3 });
        draw (opt,{ x = x + width*2/3; y = y + height/3 });
        draw (opt,{ x = x; y = y + height*2/3 });
        draw (opt,{ x = x + width/3; y = y + height*2/3 });
        draw (opt,{ x = x + width*2/3; y = y + height*2/3 });
      ] in fold @T (\(s:T) (x:T) -> new Comp s x) center arr;
  body = `
    \Graph { width = init.width; height = init.height } [
      \Rect(init)
      \draw(init)
    ]
  `;
};

(new doc @HTML @Hex , html' , svg , color).body.html
