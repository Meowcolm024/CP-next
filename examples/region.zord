--> "the universal region contains the origin"

type HudakSig<Region> = {
  Circle    : Double -> Region;
  Outside   : Region -> Region;
  Union     : Region -> Region -> Region;
  Intersect : Region -> Region -> Region;
};

type Print = { description : String };
print = trait implements HudakSig<Print> => {
  (Circle      r).description = "a circle of radius " ++ toString r;
  (Outside     a).description = "outside " ++ a.description;
  (Union     a b).description = "the union of " ++ a.description ++
                                " and " ++ b.description;
  (Intersect a b).description = "the intersection of " ++ a.description ++
                                " and " ++ b.description;
};

type Vector = { x : Double; y : Double };
type Eval = { contains : Vector -> Bool };
eval = trait implements HudakSig<Eval> => {
  (Circle      r).contains p = p.x * p.x + p.y * p.y <= r * r;
  (Outside     a).contains p = !(a.contains p);
  (Union     a b).contains p = a.contains p || b.contains p;
  (Intersect a b).contains p = a.contains p && b.contains p;
};

type HoferSig<Region> = HudakSig<Region> & {
  Univ  : Region;
  Empty : Region;
  Scale : Vector -> Region -> Region;
};

print' = trait implements HoferSig<Print> inherits print => {
  (Univ        ).description = "the universal region";
  (Empty       ).description = "the empty region";
  (Scale {..} a).description = "a region scaling " ++ a.description ++
                      " by (" ++ toString x ++ "," ++ toString y ++ ")";
};

eval' = trait implements HoferSig<Eval> inherits eval => {
  (Univ        ).contains _ = true;
  (Empty       ).contains _ = false;
  (Scale {..} a).contains p = a.contains {x = p.x / x; y = p.y / y};
};

type IsUniv  = { isUniv  : Bool };
type IsEmpty = { isEmpty : Bool };

chkUniv = trait implements HoferSig<IsEmpty => IsUniv> => {
  (Univ     ).isUniv = true;
  (Outside a).isUniv = a.isEmpty;
  (Union a b).isUniv = a.isUniv || b.isUniv;
  (Scale _ a).isUniv = a.isUniv;
            _.isUniv = false;
};

chkEmpty = trait implements HoferSig<IsUniv => IsEmpty> => {
  (Empty        ).isEmpty = true;
  (Outside     a).isEmpty = a.isUniv;
  (Intersect a b).isEmpty = a.isEmpty || b.isEmpty;
  (Scale     _ a).isEmpty = a.isEmpty;
                _.isEmpty = false;
};

type Opt Region = { optimized : Region };
opt Region = trait [fself : HoferSig<Region>]
             implements HoferSig<IsUniv&IsEmpty&Region => Opt Region> => {
  _.optimized = if self.isUniv then new Univ
                else if self.isEmpty then new Empty
                else self;
};

repo Region = trait [self : HoferSig<Region>] => {
  annulus = new Intersect (new Outside (new Circle 4.0)) (new Circle 8.0);
  ellipse = new Scale {x = 4.0; y = 8.0} (new Circle 1.0);
  univ = new Union (new Outside (new Empty)) (new Circle 1.0);
};

shapes = new repo @(Eval & Print & IsUniv & IsEmpty & Opt (Eval&Print)) ,
             eval' , print' , chkUniv , chkEmpty , opt @(Eval&Print);
shapes.univ.optimized.description ++
 (if shapes.univ.contains {x = 0.0; y = 0.0} then " contains "
  else " does not contain ") ++ "the origin"
